plugins {
    id 'com.modrinth.minotaur' version '2.+' apply false
    id "org.jetbrains.gradle.plugin.idea-ext" version "1.1.+"
    id "io.github.pacifistmc.forgix" version "2.+"
}

interface PlatformInfoExtension {
    // Which platform (i.e. Fabric/Forge/Quilt) is this implementation is on?
    // In case of projects uses solely VanillaGradle, here we use 'Vanilla'.
    Property<String> getPlatform();
    // Which Minecraft version is this implementation based on?
    Property<String> getMinecraftVersion();
    // Which Minecraft version is this implementation compatible with?
    ListProperty<String> getSupportedMinecraftVersions();
}

def mainVersion = '1.0.3'
def java17Version = ['1.18.2', '1.19.4', '1.20.1'] as Set
def allVersion = ['1.18.2', '1.19.4', '1.20.1', '1.20.4', '1.21.1']

subprojects { Project p ->
    apply plugin: 'java'
    apply plugin: 'com.modrinth.minotaur' // https://stackoverflow.com/a/50153617

    var platformInfo = p.extensions.create('platformInfo', PlatformInfoExtension)

    java.toolchain.languageVersion = JavaLanguageVersion.of(platformInfo.getMinecraftVersion().getOrElse("null") in java17Version ? 17 : 21)
    java.withSourcesJar()

    p.archivesBaseName = "ExampleMultiProjectMod"
    p.version = mainVersion

    p.repositories {
        // Enable maven central for all subprojects
        mavenCentral()
        // Enable sponge maven for all subprojects, for access to Mixin
        maven {
            name = 'SpongePowered'
            url = 'https://repo.spongepowered.org/repository/maven-public/'
            content {
                includeGroup 'org.spongepowered'
            }
        }
    }

    if (!p.name.startsWith('share')) {
        p.dependencies {
            implementation project(':share')
        }
    }

    p.tasks.withType(JavaCompile).configureEach {
        it.options.encoding = 'UTF-8'
    }

    p.processResources {
        // Exclude .cache directory which is generated by DataGen.
        exclude '.cache'
    }

    p.afterEvaluate { Project pAfter ->

        if (!pAfter.name.startsWith('share') && !pAfter.name.endsWith('base')) {
            String baseProject = ':' + pAfter.name.substring(0, pAfter.name.indexOf('-')) + '-base'
            pAfter.compileJava {
                source(pAfter.project(baseProject).sourceSets.main.allSource)
            }
            pAfter.sourcesJar {
                from project(baseProject).sourceSets.main.allJava
            }
            pAfter.processResources {
                from project(baseProject).sourceSets.main.resources
            }

            if (pAfter.name.endsWith('fabric')) {
                pAfter.tasks.named("remapJar").configure {
                    duplicatesStrategy = DuplicatesStrategy.INCLUDE
                    from pAfter.sourceSets.main.output
                    from project(baseProject).sourceSets.main.output
                }
            }
        }

        def projectExt = pAfter.extensions.platformInfo as PlatformInfoExtension

        def useLoom = pAfter.extensions.findByName('loom')

        if (useLoom) {
            pAfter.loom {
                // Uncomment this if you have Mixin configurations
                // mixin {
                //     // Enable legacy Mixin AP properties, so that we can override
                //     // default refmap file name.
                //     useLegacyMixinAp = true
                //     defaultRefmapName = 'examplemod.refmap.json'
                // }
            }
        }

        pAfter.archivesBaseName += "-${projectExt.platform.get()}-${projectExt.minecraftVersion.get()}"

        pAfter.modrinth {
            token = System.getenv("MODRINTH_TOKEN")
            projectId = System.getenv("MODRINTH_PROJECT_ID")
            loaders = [projectExt.platform.get().toLowerCase(Locale.ROOT)]
            gameVersions = projectExt.supportedMinecraftVersions.getOrElse([])
            uploadFile = useLoom ? pAfter.remapJar : pAfter.jar
            versionNumber = mainVersion
            versionType = 'release' // alpha | beta | release
            // TODO Declare Dependency
        }
        if ("Vanilla" == projectExt.platform.get()) {
            // Disable modrinth task for base projects
            pAfter.tasks.named("modrinth") {
                enabled = false
            }
        }

        pAfter.jar {
            manifest.attributes([
                    "Specification-Title"   : "Example-Mod",
                    "Specification-Vendor"  : "Whoever comes up with the spec of the mod",
                    "Specification-Version" : "1.0",
                    "Implementation-Title"  : "${pAfter.archivesBaseName}",
                    "Implementation-Version": "${pAfter.version}",
                    "Implementation-Vendor" : "Whoever actually writes the mod"
            ])
        }
    }

}

allprojects {
    configurations.configureEach {
        resolutionStrategy {
            cacheDynamicVersionsFor 30, 'days'
            cacheChangingModulesFor 30, 'days'
        }
    }
}

//forgix {
//    silence = false
//    autoRun = true
//    archiveClassifier = "all-platforms"
//    archiveVersion = mainVersion
//
//    allVersion.forEach { ver ->
//        merge(ver + '-fabric') {
//            inputJar = project(':' + ver + '-fabric').tasks.jar.archiveFile
//        }
//
//        if (ver in java17Version) {
//            merge(ver + '-forge') {
//                inputJar = project(':' + ver + '-forge').tasks.jar.archiveFile
//            }
//        } else {
//            merge(ver + '-neoforge') {
//                inputJar = project(':' + ver + '-neoforge').tasks.jar.archiveFile
//            }
//        }
//    }
//}

//forgix {
//    silence = false
//    autoRun = true
//    archiveClassifier = "all-platforms"
//    archiveVersion = mainVersion
//    multiversion {
//        gradle.projectsEvaluated {
//            def providers = subprojects
//                    .findAll { /*it.name.endsWith('fabric') ||*/ it.name.endsWith('forge') || it.name.endsWith('neoforge') }
//                    .collect { p ->
//                        if (p.name.endsWith('fabric')) {
//                            p.tasks.named('remapJar', AbstractArchiveTask).flatMap { t -> t.archiveFile }
//                        } else {
//                            p.tasks.named('jar', Jar).flatMap { t -> t.archiveFile }
//                        }
//                    }
//
//            inputJars.from(providers)
//        }
//    }
//}

def targetLoader = (findProperty("targetLoader") ?: "forge").toString()

forgix {
    silence = false
    autoRun = false
    archiveVersion = mainVersion
    archiveClassifier = "${targetLoader}"

    multiversion {
        gradle.projectsEvaluated {
            def providers = subprojects
                    .findAll { p ->
                        p.name.endsWith(targetLoader)
                    }
                    .collect { p ->
                        if (targetLoader == "fabric") {
                            p.tasks.named('remapJar', AbstractArchiveTask).flatMap { t -> t.archiveFile }
                        } else {
                            p.tasks.named('jar', Jar).flatMap { t -> t.archiveFile }
                        }
                    }
            inputJars.from(providers)
        }
    }
}

tasks.register("buildFabric", GradleBuild) {
    group = "build"
    description = "Build everything for Fabric."
    tasks = ["build", "mergeVersion"]
    startParameter.projectProperties.put("targetLoader", "fabric")
}

tasks.register("buildForge", GradleBuild) {
    group = "build"
    description = "Build everything for Forge/FeoForge."
    tasks = ["build", "mergeVersion"]
    startParameter.projectProperties.put("targetLoader", "forge")
}